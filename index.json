[
{
	"uri": "https://masonchu.github.io/golang/gvm-go-version/",
	"title": "使用 GVM 管理 go 版本",
	"tags": ["golang"],
	"description": "",
	"content": " 基本介紹 GVM 是一套管理 golang 版本的套件，類似於 nodeJS / nvm。\u0008\u0008\n\u0008安裝 GVM bash \u0026lt; \u0026lt;(curl -s -S -L https://raw.githubusercontent.com/moovweb/gvm/master/binscripts/gvm-installer)  安裝之後應該會在 bashrc \u0008下加入 source \u0008的指令，\u0008如果安裝完還是找不到 gvm \u0008指令就需要檢查一下這塊。\nsource \u0026quot;/Users/\u0008\u0026lt;username\u0026gt;/.gvm/scripts/gvm\u0026quot;  \u0008首次使用 GVM 使用 GVM 安裝 Go1.4 與之後版本。go1.4 版本之後\u0008使用 go \u0008對自己編譯，\u0008因此沒有安裝 go 的狀況下之後的版本都是無法編譯的。\ngvm install go1.4 --binary # 直接安裝 binary gvm use go1.4 # 使用 go1.4 的環境 export GOROOTBOOTSTRAP=$GOROOT # 設定 $GOROOTBOOTSTRAP gvm install go1.6 # 安裝 Go 1.6 Installing go1.6...  常用指令 gvm list\t- 列出全部已經安裝的版本 gvm listall\t- \u0008列出線上可安裝版本 gvm use\t- \u0008切換使用特定版本  Reference https://github.com/moovweb/gvm\nhttps://blog.longwin.com.tw/2016/11/golang-gvm-go-version-manager-install-2016/\n"
},
{
	"uri": "https://masonchu.github.io/golang/",
	"title": "golang",
	"tags": [],
	"description": "",
	"content": " \u0008前言 2017 跳脫\u0008待了9年的微軟圈，一方面是想要挑戰自己能更接觸到更大型完整的系統，\u0008另一方面也是受夠了在 mac \u0008裡面安裝 parallels。\u0008結果一離開微軟就做了不少改變，\u0008更開放也更接觸 open source，\u0008開發跟部屬環境對非 windows \u0008的支援也更全面。\u0008\n\u0008為什麼選擇 golang 由於以往都是 C# 的經驗為主，自然在挑選的時候以強型別/編譯式語言為主。java 有著跟 C# 一樣的問題，環境限制 JVM，oracle 也開始想盡辦法要在 licence 這上面撈一些。\u0008看到 golang 高效能\u0008高併發，\u0008還支援大多數 OS 不用額外安裝環境，\u0008光是想到就等不及要入坑。\n"
},
{
	"uri": "https://masonchu.github.io/microservices/",
	"title": "開始 microservices",
	"tags": [],
	"description": "",
	"content": " monolithic vs microservices 以往在建構大型系統的時候，\u0008本來也就是會區分成多個\u0008部分來進行。像是常見的金流物流系統，就是將部分系統功能區分出去。\u0008\u0008microservices \u0008則是將這種概念又更\u0008延伸到極致。\n前置作業 \u0008開始進行 microservices \u0008至少要具備的基本建設。\u0008\n開發相關配置  服務發現 service discovery\n k8s etcd consul zookeeper Netflix/eureka  事件訊息 event sourcing messaging  kafka  系統監控 monitor\n metrics \u0008訊息傳遞 transport  grpc thrift http  \u0008斷路器 Circuit Breaker 紀錄追蹤 Log Tracking  opentracing zipkin  Auth  Devops  CI / CD Docker k8s  golang 相關套件  go-kit https://github.com/go-kit/kit go-micro https://github.com/micro/go-micro gizmo https://github.com/nytimes/gizmo rpcx https://github.com/smallnest/rpcx  造成延伸問題 microservices solve organizational problems\nmicroservices cause technical problems\nReference Go + Microservices = Go Kit [I] - Peter Bourgon, Go Kit https://www.youtube.com/watch?v=NX0sHF8ZZgw\n微服務基礎建設 - Service Discovery http://columns.chicken-house.net/2017/12/31/microservice9-servicediscovery/ \u0008\n"
},
{
	"uri": "https://masonchu.github.io/golang/golang-cobra/",
	"title": "Cobra 強大的 Golang 命令列工具",
	"tags": ["microservice"],
	"description": "",
	"content": " 基本介紹 Cobra 是一套可以快速可以快速建立 golang CLI 工具的套件。在 golang 的生態圈內到處都可以看到相關的痕跡\u0008。最有名的包含 docker, k8s 都使用 cobra 處理 CLI 介面。\n\u0008使用方法 \u0008安裝 如果已經準備好 go 的環境，只需要執行 go get 就可以將 cobra \u0008加入安裝。\ngo get -u github.com/spf13/cobra/cobra  \u0008建立根命令 cobra init   注意如果目錄下已經有檔案會出現 Cobra will not create a new project in a non empty directory，這時候新開目錄建立之後把全部資料移過來就可以。\u0008（需要修改 main.go import 路徑）\n 應該會建立以下檔案 + cmd\nroot.go + main.go\npackage main func main() { cmd.Execute() }  這時候只要執行 go run main.go 就會顯示 cobra 預設的 CLI 指令。\nA longer description that spans multiple lines and likely contains examples and usage of using your application. For example: Cobra is a CLI library for Go that empowers applications. This application is a tool to generate the needed files to quickly create a Cobra application.  \u0008加入額外命令 cobra add \u0026lt;command name\u0026gt;  \u0008使用外部參數 預設使用 viper 套件處理環境變數。\nReference https://github.com/spf13/cobra\n"
},
{
	"uri": "https://masonchu.github.io/microservices/install-and-start-nsq/",
	"title": "安裝和啟用 NSQ 服務",
	"tags": ["microservice"],
	"description": "",
	"content": " \u0008安裝 NSQ \u0008在本機測試環境 \u0008NSQ 本身有提供 brew / docker \u0008版本。在這邊我是直接使用 github 原始碼下載\u0008\u0008編譯，\u0008注意 golang 1.7+ \u0008並且已經有 dep \u0008套件管理。在 test.sh \u0008\u0008會執行 golang test \u0026amp; 編譯出所有的可執行檔。\n下載 source code \u0026amp; 安裝相依性套件 git clone https://github.com/nsqio/nsq $GOPATH/src/github.com/nsqio/nsq cd $GOPATH/src/github.com/nsqio/nsq dep ensure  測試 \u0026amp; 編譯 ./test.sh  安裝 NSQ 安裝至 /usr/local/bin 目錄\nmake install  依序啟動服務 \u0008nsqlookupd 預設監聽 http:4161 / tcp:4160\u0008，而 nsqd 啟動時自動到 \u0008nsqlookupd 註冊。\nnsqlookupd nsqd --lookupd-tcp-address=127.0.0.1:4160 nsqadmin --lookupd-http-address=127.0.0.1:4161  \u0008使用 go-nsq \u0008發布與接受訊息 發佈\u0008環境配置 使用在 microservices \u0008中時候，\u0008nsqd 建議並不是全部 services 共用，\u0008而是個別配置一個 localhost 的 nsqd \u0008註冊到 nsqlookupd。\n You may have your nsqds and nsqlookupds segregated so that all nodes are good candidates (we do this also), but this isn\u0026rsquo;t a requirement. nsqlookupd can handle several nsqd \u0026ldquo;clusters\u0026rdquo; with distinct responsibilities, like a service discovery service.\nWhen you get the nodes back you\u0026rsquo;ll have to make a decision about which node you want to publish to. In our setup we either publish to localhost if nsqd is on the same box or a VIP.\n Reference https://nsq.io/deployment/production.html\nhttps://github.com/nsqio/go-nsq/issues/170\nhttps://segmentfault.com/a/1190000009194607\n"
},
{
	"uri": "https://masonchu.github.io/post/first-hugo/",
	"title": "第一次使用 Hugo 就上手",
	"tags": ["hugo"],
	"description": "",
	"content": " 基本介紹 Hugo 是一套生成靜態頁面的工具(static site generator)。\u0008利用 Markdown 將內容跟樣式外觀完整分開\u0008，再利用生成的靜態網頁直接發佈到 server 上。般來說 markdown \u0008語法對應樣式種類會比較少，\u0008但是相對的也是幫助在寫作的時候專注在內容而不是樣式上。\n與動態的 blog 平台比較 優點  \u0008\u0008很容易對文章內容進行 \u0008git 版控\u0008或是多人協作\n 生成的靜態網頁瀏覽速度很快，\u0008也不需要對 server \u0008系統依賴\n 容易互相在\u0008同類型的\u0008靜態生成工具之間轉換，\u0008只要把 markdown 的文章內容帶著走就好了\n  缺點  需要熟悉 markdown , git\n \u0008通常不會有線上編輯模式或是管理平台\n 如果想要取得流量或讀者留言需要註冊其他服務  \u0008第一次安裝 \u0008如果是 mac OS 只要執行\nbrew install hugo  \u0008就可以直接安裝完成，之後進入選定好\u0008儲存檔案的目錄下\nhugo new site \u0008\u0026lt;SiteName\u0026gt;  \u0008就會建立出預設的檔案目錄\n建議第一篇 post hugo new post/my-first-post.md  建立後的 md 檔案產生在 content/post 目錄\n選擇\u0008 \u0008Theme 挑選寫作工具 常用指令 \u0008\u0008//\u0008 建立\u0008可以發佈的靜態檔案 hugo // 建立 local 端 server 連同草稿 hugo server --buildDrafts  Hugo 官網說明文件 \u0008https://gohugo.io/overview/quickstart/\n"
},
{
	"uri": "https://masonchu.github.io/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://masonchu.github.io/tags/golang/",
	"title": "Golang",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://masonchu.github.io/",
	"title": "Home",
	"tags": [],
	"description": "List the child pages of a page",
	"content": "  使用 GVM 管理 go 版本  基本介紹 GVM 是一套管理 golang 版本的套件，類似於 nodeJS / nvm。\u0008\u0008 \u0008安裝 GVM bash \u0026lt; \u0026lt;(curl -s -S -L https://raw.githubusercontent.com/moovweb/gvm/master/binscripts/gvm-installer) 安裝之後應該會在 bashrc \u0008下加入 source \u0008的指令，\u0008如果安裝完還是找不到 gvm \u0008指令就需要檢查一下這塊。 source \u0026quot;/Users/\u0008\u0026lt;username\u0026gt;/.gvm/scripts/gvm\u0026quot; \u0008首次使用 GVM 使用 GVM 安裝 Go1.4 與之後版本。go1.4 版本之後\u0008使用 go \u0008對自己編譯，\u0008因此沒有安裝 go 的狀況下之後的版本都是無法編譯的。 gvm install go1.4 --binary # 直接安裝 binary gvm use go1.4 # 使用 go1.4 的環境 export GOROOTBOOTSTRAP=$GOROOT # 設定 $GOROOTBOOTSTRAP gvm install go1.6 # 安裝 Go 1.6 Installing go1.6... 常用指令 gvm list\t- 列出全部已經安裝的版本 gvm listall\t- \u0008列出線上可安裝版本 gvm use\t- \u0008切換使用特定版本 Reference https://github.\n golang  \u0008前言 2017 跳脫\u0008待了9年的微軟圈，一方面是想要挑戰自己能更接觸到更大型完整的系統，\u0008另一方面也是受夠了在 mac \u0008裡面安裝 parallels。\u0008結果一離開微軟就做了不少改變，\u0008更開放也更接觸 open source，\u0008開發跟部屬環境對非 windows \u0008的支援也更全面。\u0008 \u0008為什麼選擇 golang 由於以往都是 C# 的經驗為主，自然在挑選的時候以強型別/編譯式語言為主。java 有著跟 C# 一樣的問題，環境限制 JVM，oracle 也開始想盡辦法要在 licence 這上面撈一些。\u0008看到 golang 高效能\u0008高併發，\u0008還支援大多數 OS 不用額外安裝環境，\u0008光是想到就等不及要入坑。\n 開始 microservices  monolithic vs microservices 以往在建構大型系統的時候，\u0008本來也就是會區分成多個\u0008部分來進行。像是常見的金流物流系統，就是將部分系統功能區分出去。\u0008\u0008microservices \u0008則是將這種概念又更\u0008延伸到極致。 前置作業 \u0008開始進行 microservices \u0008至少要具備的基本建設。\u0008 開發相關配置 服務發現 service discovery k8s etcd consul zookeeper Netflix/eureka 事件訊息 event sourcing messaging kafka 系統監控 monitor metrics \u0008訊息傳遞 transport grpc thrift http \u0008斷路器 Circuit Breaker 紀錄追蹤 Log Tracking opentracing zipkin Auth Devops CI / CD Docker k8s golang 相關套件 go-kit https://github.com/go-kit/kit go-micro https://github.com/micro/go-micro gizmo https://github.com/nytimes/gizmo rpcx https://github.\n Cobra 強大的 Golang 命令列工具  基本介紹 Cobra 是一套可以快速可以快速建立 golang CLI 工具的套件。在 golang 的生態圈內到處都可以看到相關的痕跡\u0008。最有名的包含 docker, k8s 都使用 cobra 處理 CLI 介面。 \u0008使用方法 \u0008安裝 如果已經準備好 go 的環境，只需要執行 go get 就可以將 cobra \u0008加入安裝。 go get -u github.com/spf13/cobra/cobra \u0008建立根命令 cobra init 注意如果目錄下已經有檔案會出現 Cobra will not create a new project in a non empty directory，這時候新開目錄建立之後把全部資料移過來就可以。\u0008（需要修改 main.go import 路徑） 應該會建立以下檔案 + cmd root.go + main.go package main func main() { cmd.Execute() } 這時候只要執行 go run main.\n 安裝和啟用 NSQ 服務  \u0008安裝 NSQ \u0008在本機測試環境 \u0008NSQ 本身有提供 brew / docker \u0008版本。在這邊我是直接使用 github 原始碼下載\u0008\u0008編譯，\u0008注意 golang 1.7+ \u0008並且已經有 dep \u0008套件管理。在 test.sh \u0008\u0008會執行 golang test \u0026amp; 編譯出所有的可執行檔。 下載 source code \u0026amp; 安裝相依性套件 git clone https://github.com/nsqio/nsq $GOPATH/src/github.com/nsqio/nsq cd $GOPATH/src/github.com/nsqio/nsq dep ensure 測試 \u0026amp; 編譯 ./test.sh 安裝 NSQ 安裝至 /usr/local/bin 目錄 make install 依序啟動服務 \u0008nsqlookupd 預設監聽 http:4161 / tcp:4160\u0008，而 nsqd 啟動時自動到 \u0008nsqlookupd 註冊。 nsqlookupd nsqd --lookupd-tcp-address=127.0.0.1:4160 nsqadmin --lookupd-http-address=127.0.0.1:4161 \u0008使用 go-nsq \u0008發布與接受訊息 發佈\u0008環境配置 使用在 microservices \u0008中時候，\u0008nsqd 建議並不是全部 services 共用，\u0008而是個別配置一個 localhost 的 nsqd \u0008註冊到 nsqlookupd。\n posts  還不知道怎麼分類\n 第一次使用 Hugo 就上手  基本介紹 Hugo 是一套生成靜態頁面的工具(static site generator)。\u0008利用 Markdown 將內容跟樣式外觀完整分開\u0008，再利用生成的靜態網頁直接發佈到 server 上。般來說 markdown \u0008語法對應樣式種類會比較少，\u0008但是相對的也是幫助在寫作的時候專注在內容而不是樣式上。 與動態的 blog 平台比較 優點 \u0008\u0008很容易對文章內容進行 \u0008git 版控\u0008或是多人協作 生成的靜態網頁瀏覽速度很快，\u0008也不需要對 server \u0008系統依賴 容易互相在\u0008同類型的\u0008靜態生成工具之間轉換，\u0008只要把 markdown 的文章內容帶著走就好了 缺點 需要熟悉 markdown , git \u0008通常不會有線上編輯模式或是管理平台 如果想要取得流量或讀者留言需要註冊其他服務 \u0008第一次安裝 \u0008如果是 mac OS 只要執行 brew install hugo \u0008就可以直接安裝完成，之後進入選定好\u0008儲存檔案的目錄下 hugo new site \u0008\u0026lt;SiteName\u0026gt; \u0008就會建立出預設的檔案目錄 建議第一篇 post hugo new post/my-first-post.md 建立後的 md 檔案產生在 content/post 目錄 選擇\u0008 \u0008Theme 挑選寫作工具 常用指令 \u0008\u0008//\u0008 建立\u0008可以發佈的靜態檔案 hugo // 建立 local 端 server 連同草稿 hugo server --buildDrafts Hugo 官網說明文件 \u0008https://gohugo.\n "
},
{
	"uri": "https://masonchu.github.io/tags/hugo/",
	"title": "Hugo",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://masonchu.github.io/tags/microservice/",
	"title": "Microservice",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://masonchu.github.io/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://masonchu.github.io/post/",
	"title": "posts",
	"tags": [],
	"description": "還不知道怎麼分類",
	"content": "  第一次使用 Hugo 就上手  基本介紹 Hugo 是一套生成靜態頁面的工具(static site generator)。\u0008利用 Markdown 將內容跟樣式外觀完整分開\u0008，再利用生成的靜態網頁直接發佈到 server 上。般來說 markdown \u0008語法對應樣式種類會比較少，\u0008但是相對的也是幫助在寫作的時候專注在內容而不是樣式上。 與動態的 blog 平台比較 優點 \u0008\u0008很容易對文章內容進行 \u0008git 版控\u0008或是多人協作 生成的靜態網頁瀏覽速度很快，\u0008也不需要對 server \u0008系統依賴 容易互相在\u0008同類型的\u0008靜態生成工具之間轉換，\u0008只要把 markdown 的文章內容帶著走就好了 缺點 需要熟悉 markdown , git \u0008通常不會有線上編輯模式或是管理平台 如果想要取得流量或讀者留言需要註冊其他服務 \u0008第一次安裝 \u0008如果是 mac OS 只要執行 brew install hugo \u0008就可以直接安裝完成，之後進入選定好\u0008儲存檔案的目錄下 hugo new site \u0008\u0026lt;SiteName\u0026gt; \u0008就會建立出預設的檔案目錄 建議第一篇 post hugo new post/my-first-post.md 建立後的 md 檔案產生在 content/post 目錄 選擇\u0008 \u0008Theme 挑選寫作工具 常用指令 \u0008\u0008//\u0008 建立\u0008可以發佈的靜態檔案 hugo // 建立 local 端 server 連同草稿 hugo server --buildDrafts Hugo 官網說明文件 \u0008https://gohugo.\n "
}]